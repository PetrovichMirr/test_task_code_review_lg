<?php

// Небольшое лирическое отступление:
// у меня, возможно, слишком много замечаний "не совсем в тему",
// постарался взглянуть на код более широким взглядом.
// Самой логики кода я не касаюсь, потому как мне не известна задача, которую решает этот код.
//
// Здесь мы используем пространство имён для подключения классов (Database\DBHelper).
// Но в данном файле нет указания пространства имён
// (то есть код находится в глобальном пространстве имён).
// Это, в принципе, не критично, но для стройной архитектуры приложения,
// желательно иметь упорядоченную иерархию пространств имён и корневое пространство имён, например, \App
// Тогда глобальное пространство имён у нас может быть только в файле скрипта запуска приложения (index.php)
//
// В тоже время, код в данном файле исполняется в момент включения скрипта в поток выполнения.
// В зависимости от бизнес-логики и архитектуры приложения возможно допустимо
// данный код поместить в глобальное пространство имён (подобно файлу определения маршрутов-роутов в Laravel).
// Либо логику данного скрипта поместить в классы (это уже другая история).
//
// Резюме: возможно, следует перестроить иерархию пространств имён
// (например, код файла будет находиться в пространстве \App\LinkService) и
// логику данного скрипта поместить в классы.
//
// P.S. Это мелкие придирки, но всё же упомяну такой момент.
use Database\DBHelper;

// Зачем нужно включение (подгрузка) файла DB.php?
// В данном файле он нигде не используется.
// Если предположить, что файл DB.php нужен для корректной работы скрипта DBHelper.php,
// то он и должен включаться в файле DBHelper.php
//
// Второй момент. Делать подгрузку классов через require - include сейчас
// не совсем "модно" и целесообразно.
// Есть прекрасный инструмент для автозагрузки - composer.
//
// Резюме: убрать строку
// require_once 'Database/DB.php';
// Как вариант, сделать автозагрузку скриптов с помощью composer
// (тогда убрать обе строки require_once)
require_once 'Database/DB.php';
require_once 'Database/DBHelper.php';

// Нужна проверка на существование значения с ключом 'url':
// $url = isset($_POST['url']) ? $_POST['url'] : null;
// Иначе получим ошибку что-то вроде этого:
// Undefined index: url in LinkShorter.php on line ...
//
// Значение ключа параметра 'url' лучше вынести в константу,
// а не писать прямо в коде, например:
// const APP_INPUT_KEY_NAME_URL = 'url';
// $url = $_POST[APP_INPUT_KEY_NAME_URL];
// Было (выдаст ошибку):
//$url = $_POST['url'];
// Стало:
$url = isset($_POST['url']) ? $_POST['url'] : null;

// Создание экземпляров классов полезно осуществлять в одном месте,
// не разбрасывая по всему коду приложения.
// К тому же, указывая конкретный класс,
// мы увеличиваем степень взаимозависимости слоев приложения.
// Пример: в какой-то момент изменили код и теперь вместо класса DBHelper мы должны
// использовать класс DBExtraHelper - придётся искать и править код создания этого класса по всему проекту.
//
// Допустим, мы можем создавать все экземпляры с помощью фабрики.
// Пример:
// $db = Factory::createInstance(IDBHelper::class, params);
// здесь мы передаём в качестве параметра имя интерфейса IDBHelper и параметры конструктора,
// фабрика создаёт экземпляр необходимого класса.
//
// Второй момент - строку кода
// $db = new DBHelper();
// необходимо перенести в тело условия:
// if(!empty($url)) {
//     $db = new DBHelper();
//     create_url($url, $db);
//     // Можно в одну строку: create_url($url, new DBHelper());
// } else {
//     echo json_encode(['result' => 'What a fuck, url is empty!']);
// }
//
// Потому как, мы используем экземпляр DBHelper только
// при выполнении условия if(!empty($url)).
// Сейчас же экземпляр DBHelper создаётся в любом случае.
//
$db = new DBHelper();

// Нет расширенной валидации URL (на валидность URL) и обработки входных данных POST-запроса.
// Возможно, бизнес-логика и не подразумевает валидацию.
// Момент безопасности - все входные данные,
// поступающие в приложение извне (как правило, через http-запросы)
// нужно "держать под присмотром".
// Дабы обезопаситься от SQL-инъекций и прочих возможных казусов.
//
// Для обеспечения безопасности раньше рекомендовали проводить
// проверку допустимости значений и делать обработку входных данных,
// например, что-то типа $id = (int)$_GET['id'];
//
// Сейчас, на мой взгляд, более рациональная практика состоит в том, что
// фильтрация входных данных не обязательна.
// В общем случае, достаточно:
// 1) Валидации - она нужна для обеспечения корректности данных,
// чтобы все сущности приложения находились в валидном состоянии
// (например, чтобы в базу данных не попадали номера телефонов, состоящие из букв)
// и для обратной связи с клиентом (если по ошибке клиент ввёл не валидные данные,
// его необходимо уведомить об этом)
// 2) Использования подготовленных запросов при работе с базой данных для надёжной защиты от SQL-инъекций.
// Например, использовать расширение PDO + Подготовленные запросы и хранимые процедуры:
// https://www.php.net/manual/ru/pdo.prepared-statements.php
//
// Условие if(isset($url) && !empty($url))
// заменить на if(!empty($url)) - результат такой же
if (isset($url) && !empty($url)) {
    create_url($url, $db);
} else {
    // Если бизнес-логика подразумевает такой формат ответа, у меня замечаний почти нет :)))
    // за исключением того, что подобные значения строк лучше задавать не прямо в коде,
    // а выносить, допустим в константы. Почему? Удобнее, больше порядка, для локализации - мультиязычности и т.д.
    // Например так:
    // const APP_RESULT_URL_EMPTY = 'What a fuck, url is empty!';
    // echo json_encode(['result' => APP_RESULT_URL_EMPTY]);
    echo json_encode(['result' => 'What a fuck, url is empty!']);
}

function create_url($url, $db) {
    $url = trim(strtolower($url));

    // Про валидацию URL я уже писал выше.
    // Приведённое здесь условие явно не достаточно, например, адрес "абырвалгhttp://пишу_на_php" пройдёт нижеуказанную проверку
    // К тому же, если делать валидацию, её нужно размещать не в этой функции, а после получения входных данных из $_POST
    // реализовать валидацию URL можно с помощью регулярных выражений
    //
    // Ещё момент - если $url не проходит проверку ниже (не найдено вхождение подстрок 'http://' или 'https://'),
    // то у нас клиенту возвращается пустой ответ. Логично было бы дополнить код примерно так:
    // if (false !== strpos($url, 'http://') || false !== strpos($url, 'https://')) {
    //  ......
    //  } else {
    //      echo json_encode(['result' => 'What a fuck, url is invalid!']);
    //  }
    //
    if (false !== strpos($url, 'http://') || false !== strpos($url, 'https://')) {
        // Не совсем понятно, что делает этот метод createTableIfNotExist.
        // Видимо, создаёт какую-то таблицу (возможно, для хранения ссылок $url), если она не существует.
        // Если так, почему мы не передаём имя этой таблицы в параметре метода?
        $db->createTableIfNotExist();

        // Метод checkExistsUrl, судя по всему, выполняет поиск в хранилище записи по $url
        // Если $url найден - возвращает запись $res, иначе возвращает false
        // Только имя у метода не совсем удачное.
        // checkExistsUrl - по смыслу наименования возвращает true, если $url найден, иначе возвращает false
        // Лучше бы назвать этот метод как-то так: $res = $db->findUrl($url);
        $res = $db->checkExistsUrl($url);
        if ($res !== false) {
            // Опять же, текст 'link is exist and here is: ' лучше вынести в константу
            // Можно вообще создать функцию типа getResultLink($res):
            // echo json_encode(['result' =>getResultLink($res)]);
            //
            // Второй момент - может быть вместо  $_SERVER['HTTP_ORIGIN'] использовать  $_SERVER['SERVER_NAME']?
            // и лучше получение адреса хоста приложения вынести в отдельную функцию, типа getAppBaseUrl()
            echo json_encode(['result' => "link is exist and here is: <a href='" . $_SERVER['HTTP_ORIGIN'] . '/' . $res . "'>" . $_SERVER['HTTP_ORIGIN'] . '/' . $res . "</a>"]);
        } else {
            // Почему здесь другой формат ответа,
            // не такой как: ['result' => '.....']?
            // Если подразумевается такой же формат ответа в стиле ['result' => '.....'],
            // значит метод $db->createChangedLink должен возвращать ответ уже в таком формате,
            // а это не есть хорошо,
            // так как формат ответа лучше задавать в одном месте,
            // а не раскидывать по разным местам кода.
            echo json_encode(createLink($url, $db));
        }
    }
}

function createLink($url, $db) {
    // $arrChar вынести в константу или наполнить этот массив в функции.
    // А лучше создать случайное значение переменной $changedUrl каким-нибудь другим образом, например так:
    //
    // $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    // $changedUrl = substr(str_shuffle($chars), 0, 6);
    // return $db->createChangedLink($url, $changedUrl);
    //
    $arrChar = [
        'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l',
        'm', 'n', 'o', 'p', 'q', 'r',
        's', 't', 'u', 'v', 'w', 'x',
        'y', 'z', 'A', 'B', 'C', 'D',
        'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V',
        'W', 'X', 'Y', 'Z'
    ];
    $changedUrl = '/';
    for ($i = 0; $i < 6; $i++) {
        $rand = rand(0, count($arrChar) - 1);
        $changedUrl .= $arrChar[$rand];
    }
    return $db->createChangedLink($url, $changedUrl);
}
